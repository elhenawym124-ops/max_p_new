const express = require('express');
const cors = require('cors');
const path = require('path');
const { PrismaClient } = require('@prisma/client');
const http = require('http');
const socketService = require('./services/socketService');
const axios = require('axios');
const fs = require('fs');
const bcrypt = require('bcryptjs');
const multer = require('multer');
require('dotenv').config();

// Import Environment Configuration
const envConfig = require('./config/environment');

// AI Agent Integration
const aiAgentService = require('./services/aiAgentService');
const ragService = require('./services/ragService');
const memoryService = require('./services/memoryService');
// Moved to top of file
const multimodalService = require('./services/multimodalService');
//Import Routes
const MessageHealthChecker = require('./utils/messageHealthChecker');
const scheduledMaintenance = require('./services/scheduledPatternMaintenanceService');

const proxyRoutes = require('./routes/proxyRoutes');
const webhookRoutes = require('./routes/webhookRoutes');
const securityRoutes = require('./routes/securityRoutes');
const healthRoute = require('./routes/healthRoute');
const debugRoutes = require('./routes/debugRoutes');
const testRagRoutes = require('./routes/testRagRoutes');
const queueRoutes = require('./routes/queueRoutes');
const authRoutes = require('./routes/authRoutes');
const demoRoutes = require('./routes/demoRoutes');
const productRoutes = require('./routes/productRoutes');
const conversationRoutes = require('./routes/conversationRoutes');
const customerRoutes = require('./routes/customerRoutes');
const orderRoutes = require('./routes/orderRoutes');
const reportsRoutes = require('./routes/reportsRoutes');
const facebookIntegrationRoutes = require('./routes/facebookIntegrationRoutes');
const messageFixRoutes = require('./routes/messageFixRoutes');
const aiRoutes = require('./routes/aiRoutes');
const companyRoutes = require('./routes/companyRoutes');
const settingsRoutes = require('./routes/settingsRoutes');
const notificationRoutes = require('./routes/notifications-simple');
const dashboardRoutes = require('./routes/dashboardRoutes');
const companyDashboardRoutes = require('./routes/companyDashboardRoutes');
const invitationRoutes = require('./routes/invitationRoutes');


const adminAnalyticsRoutes = require('./routes/adminAnalyticsRoutes');
const adminPlansRoutes = require('./routes/adminPlansRoutes');
const invoiceRoutes = require('./routes/invoiceRoutes');
const subscriptionRoutes = require('./routes/subscriptionRoutes');
const paymentRoutes = require('./routes/paymentRoutes');
const systemManagementRoutes = require('./routes/systemManagementRoutes');
const walletPaymentRoutes = require('./routes/walletPayment');
const adminCompanyRoutes = require('./routes/adminCompanyRoutes');
const smartDelayRoutes = require('./routes/smartDelayRoutes');
const enhancedProductRoutes = require('./routes/productRoutes');
const orderRoutes2 = require('./routes/orders');
const enhancedOrderRoutes = require('./routes/enhancedOrders');


// Import Simple Monitoring System
const { simpleMonitor } = require('./services/simpleMonitor');
const monitoringRoutes = require('./routes/monitoringRoutes');
const databaseMonitorRoutes = require('./routes/databaseMonitorRoutes');

// Import Auto Pattern Detection Service
const autoPatternService = require('./services/autoPatternDetectionService');

// Import Global Security Middleware
const { globalSecurity } = require('./middleware/globalSecurity');

// Import Security Enhancements
const {
  rateLimits,
  securityHeaders,
  sanitizeRequest,
  securityMonitoring,
  enhancedCORS
} = require('./middleware/securityEnhancements');

// Emergency security patch
const emergencySecurityPatch = require('./middleware/emergencySecurityPatch');

// Set UTF-8 encoding for console output
process.stdout.setEncoding('utf8');
process.stderr.setEncoding('utf8');

console.log('ğŸš€ Starting Clean Server (No AI)...');

// Import Safe Database Utilities
const { safeDb, DatabaseHelpers } = require('./utils/safeDatabase');

// Import Database Error Handler
const { databaseErrorMiddleware, databaseHealthCheck } = require('./middleware/databaseErrorHandler');

const { getSharedPrismaClient, initializeSharedDatabase, executeWithRetry } = require('./services/sharedDatabase');

const aiQualityRoutes = require('./routes/aiQualityRoutes');
const conversationAIRoutes = require('./routes/conversationAIRoutes');


const prisma = getSharedPrismaClient();

// Helper function to generate unique IDs
function generateId() {
  return 'cm' + Math.random().toString(36).substr(2, 9) + Math.random().toString(36).substr(2, 9);
}
// Initialize Express app
const app = express();
const server = http.createServer(app);
app.use(express.json());

// Ù„Ùˆ Ø¨ØªØ³ØªÙ‚Ø¨Ù„ form data (application/x-www-form-urlencoded)
app.use(express.urlencoded({ extended: true }));
// Initialize Socket.IO
socketService.initialize(server);

// Use shared database retry utility
const withRetry = executeWithRetry;

// Set charset for responses (skip for image proxy and uploads)
app.use((req, res, next) => {
  res.charset = 'utf-8';
  // Don't set Content-Type for image proxy routes and uploads
  if (!req.path.startsWith('/api/proxy-image') && !req.path.startsWith('/uploads')) {
    res.setHeader('Content-Type', 'application/json; charset=utf-8');
  }
  next();
});

// Apply Security Enhancements
console.log('ğŸ›¡ï¸ Applying Security Enhancements...');
app.use(enhancedCORS);
app.use(securityHeaders);
app.use(sanitizeRequest);
app.use(securityMonitoring);

// Apply emergency security patch
app.use(emergencySecurityPatch);
console.log('ğŸš¨ Emergency security patch applied');

// // Apply rate limiting (disabled for development)
// if (process.env.NODE_ENV === 'production') {
//   app.use('/api/v1/auth', rateLimits.auth);
//   app.use('/api/v1/admin', rateLimits.admin);
//   app.use('/api/v1', rateLimits.api);
//   console.log('ğŸ›¡ï¸ Rate limiting enabled for production');
// } else {
//   console.log('ğŸ”§ Rate limiting disabled for development');
// }


app.use('/uploads', express.static(path.join(__dirname, 'uploads')));
app.use("/api/proxy-image", proxyRoutes);
app.use("/api/v1/webhook", webhookRoutes);

// Apply Global Security Middleware to all routes
console.log('ğŸ›¡ï¸ Applying Global Security Middleware...');
app.use(globalSecurity);

// Add monitoring routes (after security middleware)
console.log('ğŸ”§ [SERVER] Registering monitoring routes at /api/v1/monitor');
app.use('/api/v1/monitor', (req, res, next) => {
  console.log('ğŸ” [SERVER] Monitor route hit:', req.method, req.path);
  next();
}, monitoringRoutes);

// Add database monitoring routes
console.log('ğŸ”§ [SERVER] Registering database monitoring routes at /api/v1/db-monitor');
app.use('/api/v1/db-monitor', databaseMonitorRoutes);

// Global database error handler (should be after all routes)
app.use(databaseErrorMiddleware);

// Basic routes
app.get('/', (req, res) => {
  res.json({
    message: 'Chat Bot Backend - Clean Version (No AI)',
    version: '1.0.0',
    features: ['Basic messaging', 'Manual responses only']
  });
});

app.use('/api/v1/ai-quality', aiQualityRoutes);
app.use('/api/v1', conversationAIRoutes);

app.use('/api/v1/security', securityRoutes);
// Enhanced health check endpoint with database status
app.get('/health', databaseHealthCheck);
app.get('/api/health', databaseHealthCheck);
app.get('/api/v1/health', databaseHealthCheck);
app.use('/api/v1/debug', debugRoutes);

// Ø¥Ø¹Ø¯Ø§Ø¯ UTF-8 Ù„Ù„ØªØ±Ù…ÙŠØ² Ø§Ù„ØµØ­ÙŠØ­
app.use((req, res, next) => {
  res.setHeader('Content-Type', 'application/json; charset=utf-8');
  next();
});

// Basic logging middleware
app.use((req, res, next) => {
  console.log(`${req.method} ${req.path}`);
  next();
});

app.use('/api/v1/queue-stats', queueRoutes);
app.use('/api/v1/test-rag', testRagRoutes);

// Basic routes
app.get('/', (req, res) => {
  res.json({
    message: 'Chat Bot Backend - Clean Version (No AI)',
    version: '1.0.0',
    features: ['Basic messaging', 'Manual responses only']
  });
});


app.use("/api/v1/auth/", authRoutes)
app.use("/api/v1/dev/", demoRoutes)
app.use("/api/v1/products/", productRoutes)
app.use("/api/v1/conversations/", conversationRoutes)
app.use("/api/v1/customers/", customerRoutes)
app.use("/api/v1/orders/", orderRoutes)
app.use("/api/v1/reports/", reportsRoutes)
app.use("/api/v1/integrations/", facebookIntegrationRoutes)
app.use("/api/v1/messages/", messageFixRoutes)

// ==================== SERVER STARTUP ====================
const PORT = process.env.PORT || 3001;
let serverStarted = false;

async function startServer() {
  try {
    console.log('ğŸ”§ [SERVER] Initializing shared database...');
    
    // Try to initialize database with enhanced retry logic
    await initializeSharedDatabase();
    console.log('âœ… [SERVER] Shared database initialized successfully');
    
    // Start the server
    server.listen(PORT, () => {
      serverStarted = true;
      console.log(`Mahmoud Ahmed`);
      console.log(`ğŸ‰ Clean Server running on port ${PORT}`);
      console.log(`ğŸ“± Frontend URL: ${envConfig.frontendUrl}`);
      console.log(`ğŸ”— Backend URL: ${envConfig.backendUrl}`);
      console.log(`ğŸ“Š API Base URL: ${envConfig.apiUrl}`);
      console.log(`ğŸŒ WebSocket URL: ${envConfig.wsUrl}`);
      console.log(`ğŸ¤– AI Features: ENABLED`);
      console.log(`âœ… AI Agent ready for customer service`);
      console.log(`Mahmoud Ahmed`);
    });
    
  } catch (error) {
    console.error('âŒ [SERVER] Failed to initialize shared database:', error);
    
    // Check if it's a connection limit error
    if (error.message.includes('max_connections_per_hour') || error.message.includes('ERROR 42000 (1226)')) {
      console.log('ğŸš¨ [SERVER] CONNECTION LIMIT EXCEEDED - Starting server in degraded mode');
      console.log('ğŸ”„ [SERVER] Database connections will be retried automatically in background');
      
      // Start server anyway but with degraded database functionality
      server.listen(PORT, () => {
        serverStarted = true;
        console.log(`Mahmoud Ahmed`);
        console.log(`âš ï¸ Server running in DEGRADED MODE on port ${PORT}`);
        console.log(`ğŸ“± Frontend URL: ${envConfig.frontendUrl}`);
        console.log(`ğŸ”— Backend URL: ${envConfig.backendUrl}`);
        console.log(`ğŸš¨ Database: CONNECTION LIMIT EXCEEDED (will retry automatically)`);
        console.log(`ğŸ”„ Health endpoint available at: ${envConfig.backendUrl}/health`);
        console.log(`Mahmoud Ahmed`);
      });
      
      // Schedule periodic retry attempts
      scheduleConnectionRetries();
      
    } else {
      console.error('âŒ [SERVER] Critical error - shutting down');
      process.exit(1);
    }
  }
}

/**
 * Schedule periodic connection retry attempts
 */
function scheduleConnectionRetries() {
  console.log('ğŸ”„ [SERVER] Scheduling database connection retries...');
  
  const retryInterval = setInterval(async () => {
    try {
      console.log('ğŸ”„ [SERVER] Attempting to reconnect to database...');
      await initializeSharedDatabase();
      console.log('âœ… [SERVER] Database connection restored!');
      clearInterval(retryInterval);
    } catch (error) {
      if (error.message.includes('max_connections_per_hour')) {
        console.log('â³ [SERVER] Still in connection limit cooldown, will retry in 5 minutes...');
      } else {
        console.log('âš ï¸ [SERVER] Database connection failed, will retry in 5 minutes:', error.message);
      }
    }
  }, 5 * 60 * 1000); // Retry every 5 minutes
  
  // Clear retry attempts after 2 hours to prevent infinite retries
  setTimeout(() => {
    clearInterval(retryInterval);
    console.log('ğŸ• [SERVER] Stopped automatic database retry attempts after 2 hours');
  }, 2 * 60 * 60 * 1000);
}

// Start the server
startServer();
// ØªØ´ØºÙŠÙ„ ÙØ­Øµ ØµØ­Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ ÙƒÙ„ Ø³Ø§Ø¹Ø©
console.log(`ğŸ” Starting message health monitoring...`);

setInterval(async () => {
  try {
    console.log('ğŸ” [AUTO-HEALTH-CHECK] Running periodic message health check...');
    const checker = new MessageHealthChecker();
    const results = await checker.checkAllMessages();

    if (results.fixed > 0) {
      console.log(`ğŸ”§ [AUTO-HEALTH-CHECK] Fixed ${results.fixed} broken messages`);
    }

    if (results.broken > 0) {
      console.log(`âš ï¸ [AUTO-HEALTH-CHECK] Found ${results.broken} broken messages`);
    }

    await checker.disconnect();
  } catch (error) {
    console.error('âŒ [AUTO-HEALTH-CHECK] Error:', error.message);
  }
}, 60 * 60 * 1000); // ÙƒÙ„ Ø³Ø§Ø¹Ø©


// Initialize System Manager
console.log(`ğŸ”§ Initializing System Manager...`);

try {
  const systemManager = require('./services/systemManager');
  systemManager.initializeSystemSettings().then(() => {
    console.log(`âœ… System Manager initialized successfully`);
  }).catch((error) => {
    console.error(`âŒ Failed to initialize System Manager:`, error.message);
  });
} catch (error) {
  console.error(`âŒ Failed to initialize System Manager:`, error.message);
}


// Start Auto Pattern Detection Service
console.log(`ğŸ” Starting Auto Pattern Detection Service...`);
try {
  autoPatternService.start();
  console.log(`âœ… Auto Pattern Detection Service started successfully`);
  console.log(`â° Detection interval: ${autoPatternService.getStatus().intervalMinutes} minutes`);
} catch (error) {
  console.error(`âŒ Failed to start Auto Pattern Detection Service:`, error.message);
}

// Start Scheduled Pattern Maintenance Service
console.log(`ğŸ• Starting Scheduled Pattern Maintenance Service...`);
try {
  scheduledMaintenance.start();
  console.log(`âœ… Scheduled Pattern Maintenance Service started successfully`);
  console.log(`ğŸ“… Weekly cleanup: Sundays at 2:00 AM`);
  console.log(`ğŸ“… Daily maintenance: Every day at 3:00 AM`);
  console.log(`ğŸ“… Monthly archiving: 1st of month at 1:00 AM`);
} catch (error) {
  console.error(`âŒ Failed to start Scheduled Pattern Maintenance Service:`, error.message);
}

// ================================
// AI AGENT API ENDPOINTS
// ================================

// Test AI Agent directly (for testing purposes)
app.post('/test-ai-direct', async (req, res) => {
  try {
    console.log('ğŸ§ª Test AI endpoint called');
    console.log('ğŸ“¦ Request body:', req.body);

    const { conversationId, senderId, content, attachments = [], customerData } = req.body;

    if (!content) {
      return res.status(400).json({
        success: false,
        error: 'Message content is required'
      });
    }

    // Ø¥Ø¹Ø¯Ø§Ø¯ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ø±Ø³Ø§Ù„Ø©
    const messageData = {
      conversationId: conversationId || 'test-conversation',
      senderId: senderId || 'test-customer',
      content: content,
      attachments: attachments,
      customerData: customerData || {
        name: 'Ø¹Ù…ÙŠÙ„ ØªØ¬Ø±ÙŠØ¨ÙŠ',
        phone: '01234567890',
        email: 'test@example.com',
        orderCount: 0
      }
    };

    console.log('ğŸ¤– Processing with AI Agent...');
    console.log('ğŸ“¤ Message data:', JSON.stringify(messageData, null, 2));

    // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø±Ø³Ø§Ù„Ø© Ø¨Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„ØµÙ†Ø§Ø¹ÙŠ
    const aiResponse = await aiAgentService.processCustomerMessage(messageData);

    if (aiResponse) {
      console.log('âœ… AI response generated successfully');

      res.json({
        success: true,
        data: {
          content: aiResponse.content,
          intent: aiResponse.intent,
          sentiment: aiResponse.sentiment,
          confidence: aiResponse.confidence,
          shouldEscalate: aiResponse.shouldEscalate,
          images: aiResponse.images || [],
          processingTime: aiResponse.processingTime || 0,
          orderInfo: aiResponse.orderInfo || null,
          orderCreated: aiResponse.orderCreated || null
        },
        message: 'AI response generated successfully'
      });
    } else {
      console.log('âŒ No AI response generated');

      res.json({
        success: false,
        error: 'AI Agent did not generate a response',
        details: 'This could be due to AI being disabled, quota exceeded, or other configuration issues'
      });
    }

  } catch (error) {
    console.error('âŒ Error in test AI endpoint:', error);

    res.status(500).json({
      success: false,
      error: error.message,
      details: error.stack
    });
  }
});
app.use("/api/v1/ai/", aiRoutes)


// Graceful shutdown
process.on('SIGINT', async () => {
  console.log('ğŸ›‘ Shutting down server...');
  await prisma.$disconnect();
  process.exit(0);
});

app.use("/api/v1/companies/", companyRoutes)
app.use('/api/v1/settings/', settingsRoutes);
// Test notifications route (direct)
app.get('/api/v1/notifications/test', (req, res) => {
  console.log('ğŸ§ª Test notifications route called');
  res.json({ success: true, message: 'Test route works!' });
});

app.use('/api/v1/notifications', notificationRoutes);

// Get user roles
app.get('/api/v1/users/roles', (req, res) => {
  const roles = {
    COMPANY_ADMIN: {
      name: 'Ù…Ø¯ÙŠØ± Ø§Ù„Ø´Ø±ÙƒØ©',
      description: 'ØµÙ„Ø§Ø­ÙŠØ§Øª ÙƒØ§Ù…Ù„Ø© Ù„Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø´Ø±ÙƒØ© ÙˆØ§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†',
      permissions: [
        'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†',
        'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø¯ÙˆØ§Ø±',
        'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª',
        'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡',
        'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø·Ù„Ø¨Ø§Øª',
        'Ù…Ø´Ø§Ù‡Ø¯Ø© Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±',
        'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª',
        'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªÙƒØ§Ù…Ù„Ø§Øª'
      ]
    },
    MANAGER: {
      name: 'Ù…Ø¯ÙŠØ±',
      description: 'ØµÙ„Ø§Ø­ÙŠØ§Øª Ø¥Ø¯Ø§Ø±ÙŠØ© Ù…Ø­Ø¯ÙˆØ¯Ø©',
      permissions: [
        'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª',
        'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡',
        'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø·Ù„Ø¨Ø§Øª',
        'Ù…Ø´Ø§Ù‡Ø¯Ø© Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±'
      ]
    },
    AGENT: {
      name: 'Ù…ÙˆØ¸Ù',
      description: 'ØµÙ„Ø§Ø­ÙŠØ§Øª Ø£Ø³Ø§Ø³ÙŠØ© Ù„Ù„Ø¹Ù…Ù„ Ø§Ù„ÙŠÙˆÙ…ÙŠ',
      permissions: [
        'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡',
        'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø·Ù„Ø¨Ø§Øª',
        'Ù…Ø´Ø§Ù‡Ø¯Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª'
      ]
    }
  };

  res.json({
    success: true,
    message: 'ØªÙ… Ø¬Ù„Ø¨ Ø§Ù„Ø£Ø¯ÙˆØ§Ø± Ø¨Ù†Ø¬Ø§Ø­',
    data: roles
  });
});

// ==================== ROLES & PERMISSIONS MANAGEMENT ====================
// Get all available permissions
app.get('/api/v1/permissions', (req, res) => {
  const permissions = {
    'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†': {
      key: 'manage_users',
      category: 'Ø¥Ø¯Ø§Ø±Ø©',
      description: 'Ø¥Ø¶Ø§ÙØ© ÙˆØªØ¹Ø¯ÙŠÙ„ ÙˆØ­Ø°Ù Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†'
    },
    'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø£Ø¯ÙˆØ§Ø±': {
      key: 'manage_roles',
      category: 'Ø¥Ø¯Ø§Ø±Ø©',
      description: 'Ø¥Ù†Ø´Ø§Ø¡ ÙˆØªØ¹Ø¯ÙŠÙ„ Ø§Ù„Ø£Ø¯ÙˆØ§Ø± ÙˆØ§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª'
    },
    'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª': {
      key: 'manage_products',
      category: 'Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª',
      description: 'Ø¥Ø¶Ø§ÙØ© ÙˆØªØ¹Ø¯ÙŠÙ„ ÙˆØ­Ø°Ù Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª'
    },
    'Ù…Ø´Ø§Ù‡Ø¯Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª': {
      key: 'view_products',
      category: 'Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª',
      description: 'Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ù†ØªØ¬Ø§Øª ÙÙ‚Ø·'
    },
    'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡': {
      key: 'manage_customers',
      category: 'Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡',
      description: 'Ø¥Ø¶Ø§ÙØ© ÙˆØªØ¹Ø¯ÙŠÙ„ ÙˆØ­Ø°Ù Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡'
    },
    'Ù…Ø´Ø§Ù‡Ø¯Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡': {
      key: 'view_customers',
      category: 'Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡',
      description: 'Ø¹Ø±Ø¶ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ ÙÙ‚Ø·'
    },
    'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø·Ù„Ø¨Ø§Øª': {
      key: 'manage_orders',
      category: 'Ø§Ù„Ø·Ù„Ø¨Ø§Øª',
      description: 'Ø¥Ù†Ø´Ø§Ø¡ ÙˆØªØ¹Ø¯ÙŠÙ„ ÙˆØ­Ø°Ù Ø§Ù„Ø·Ù„Ø¨Ø§Øª'
    },
    'Ù…Ø´Ø§Ù‡Ø¯Ø© Ø§Ù„Ø·Ù„Ø¨Ø§Øª': {
      key: 'view_orders',
      category: 'Ø§Ù„Ø·Ù„Ø¨Ø§Øª',
      description: 'Ø¹Ø±Ø¶ Ø§Ù„Ø·Ù„Ø¨Ø§Øª ÙÙ‚Ø·'
    },
    'Ù…Ø´Ø§Ù‡Ø¯Ø© Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±': {
      key: 'view_reports',
      category: 'Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±',
      description: 'Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„ØªÙ‚Ø§Ø±ÙŠØ± ÙˆØ§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª'
    },
    'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±': {
      key: 'manage_reports',
      category: 'Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±',
      description: 'Ø¥Ù†Ø´Ø§Ø¡ ÙˆØªØ®ØµÙŠØµ Ø§Ù„ØªÙ‚Ø§Ø±ÙŠØ±'
    },
    'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª': {
      key: 'manage_settings',
      category: 'Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª',
      description: 'ØªØ¹Ø¯ÙŠÙ„ Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø´Ø±ÙƒØ©'
    },
    'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªÙƒØ§Ù…Ù„Ø§Øª': {
      key: 'manage_integrations',
      category: 'Ø§Ù„ØªÙƒØ§Ù…Ù„Ø§Øª',
      description: 'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„ØªÙƒØ§Ù…Ù„Ø§Øª Ù…Ø¹ Ø§Ù„Ø£Ù†Ø¸Ù…Ø© Ø§Ù„Ø®Ø§Ø±Ø¬ÙŠØ©'
    },
    'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª': {
      key: 'manage_conversations',
      category: 'Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª',
      description: 'Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª ÙˆØ§Ù„Ø±Ø³Ø§Ø¦Ù„'
    },
    'Ù…Ø´Ø§Ù‡Ø¯Ø© Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª': {
      key: 'view_conversations',
      category: 'Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª',
      description: 'Ø¹Ø±Ø¶ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª ÙÙ‚Ø·'
    }
  };

  res.json({
    success: true,
    message: 'ØªÙ… Ø¬Ù„Ø¨ Ø§Ù„ØµÙ„Ø§Ø­ÙŠØ§Øª Ø¨Ù†Ø¬Ø§Ø­',
    data: permissions
  });
});

// ==================== DASHBOARD SERVICE ROUTES ====================
app.use('/api/v1/dashboard', dashboardRoutes);


// ==================== COMPANY DASHBOARD ROUTES ====================
app.use('/api/v1/company', companyDashboardRoutes);
app.use('/api/v1/invitations', invitationRoutes);

// ==================== SUPER ADMIN ROUTES ====================

// Super Admin Analytics Routes
app.use('/api/v1/admin/analytics', adminAnalyticsRoutes);

// Super Admin Plans Routes
app.use('/api/v1/admin/plans', adminPlansRoutes);

// Super Admin Subscription Routes
app.use('/api/v1/admin/subscriptions', subscriptionRoutes);

// Super Admin Invoice Routes
app.use('/api/v1/admin/invoices', invoiceRoutes);

// Super Admin Payment Routes
app.use('/api/v1/admin/payments', paymentRoutes);

// Super Admin System Management Routes
app.use('/api/v1/admin', systemManagementRoutes);

// Wallet Payment Routes (Ø¯ÙØ¹ Ø§Ù„Ù…Ø­Ø§ÙØ¸ Ù„Ù„Ø¹Ù…Ù„Ø§Ø¡)
app.use('/api/v1/wallet-payment', walletPaymentRoutes);

// Initialize Billing Notification Service
const BillingNotificationService = require('./services/billingNotificationService');
const billingNotificationService = new BillingNotificationService();

// Initialize Subscription Renewal Service
const SubscriptionRenewalService = require('./services/subscriptionRenewalService');
const subscriptionRenewalService = new SubscriptionRenewalService();

// Start billing notifications after server is ready
setTimeout(() => {
  billingNotificationService.start();

  // Add renewal processing to daily checks
  const originalRunDailyChecks = billingNotificationService.runDailyChecks;
  billingNotificationService.runDailyChecks = async function() {
    await originalRunDailyChecks.call(this);
    await subscriptionRenewalService.processAutomaticRenewals();
  };
}, 5000); // Wait 5 seconds for server to fully initialize


app.use('/api/v1/admin/companies', adminCompanyRoutes);
const verifyToken = require("./utils/verifyToken")

app.get('/api/v1/admin/statistics', verifyToken.authenticateToken, verifyToken.requireSuperAdmin, async (req, res) => {
  try {
    const [
      totalCompanies,
      activeCompanies,
      totalUsers,
      totalCustomers,
      totalConversations,
      totalMessages,
      companiesByPlan
    ] = await Promise.all([
      prisma.company.count(),
      prisma.company.count({ where: { isActive: true } }),
      prisma.user.count(),
      prisma.customer.count(),
      prisma.conversation.count(),
      prisma.message.count(),
      prisma.company.groupBy({
        by: ['plan'],
        _count: { plan: true }
      })
    ]);

    // Get recent activity (last 30 days)
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const [
      newCompaniesLast30Days,
      newUsersLast30Days,
      newCustomersLast30Days
    ] = await Promise.all([
      prisma.company.count({
        where: { createdAt: { gte: thirtyDaysAgo } }
      }),
      prisma.user.count({
        where: { createdAt: { gte: thirtyDaysAgo } }
      }),
      prisma.customer.count({
        where: { createdAt: { gte: thirtyDaysAgo } }
      })
    ]);

    res.json({
      success: true,
      message: 'ØªÙ… Ø¬Ù„Ø¨ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù†Ø¸Ø§Ù… Ø¨Ù†Ø¬Ø§Ø­',
      data: {
        overview: {
          totalCompanies,
          activeCompanies,
          inactiveCompanies: totalCompanies - activeCompanies,
          totalUsers,
          totalCustomers,
          totalConversations,
          totalMessages
        },
        planDistribution: companiesByPlan.reduce((acc, item) => {
          acc[item.plan] = item._count.plan;
          return acc;
        }, {}),
        recentActivity: {
          newCompaniesLast30Days,
          newUsersLast30Days,
          newCustomersLast30Days
        }
      }
    });

  } catch (error) {
    console.error('âŒ Error fetching statistics:', error);
    res.status(500).json({
      success: false,
      message: 'ÙØ´Ù„ ÙÙŠ Ø¬Ù„Ø¨ Ø§Ù„Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª',
      error: error.message
    });
  }
});

// ==================== DEVELOPMENT HELPERS ====================
// Create test user endpoint (for development only)
app.post('/api/v1/dev/create-test-user', async (req, res) => {
  try {
    // Check if we're in development
    if (process.env.NODE_ENV === 'production') {
      return res.status(403).json({
        success: false,
        message: 'Ù‡Ø°Ø§ Ø§Ù„Ù€ endpoint Ù…ØªØ§Ø­ ÙÙ‚Ø· ÙÙŠ Ø¨ÙŠØ¦Ø© Ø§Ù„ØªØ·ÙˆÙŠØ±'
      });
    }

    // Get the first company
    const company = await prisma.company.findFirst();
    if (!company) {
      return res.status(404).json({
        success: false,
        message: 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø´Ø±ÙƒØ§Øª ÙÙŠ Ø§Ù„Ù†Ø¸Ø§Ù…'
      });
    }

    // Check if test user already exists
    const existingUser = await prisma.user.findFirst({
      where: { email: 'admin@test.com' }
    });

    if (existingUser) {
      return res.json({
        success: true,
        message: 'Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠ Ù…ÙˆØ¬ÙˆØ¯ Ø¨Ø§Ù„ÙØ¹Ù„',
        data: {
          email: 'admin@test.com',
          password: 'admin123',
          role: existingUser.role,
          companyId: existingUser.companyId
        }
      });
    }

    // Create test user
    const hashedPassword = await bcrypt.hash('admin123', 12);

    const testUser = await prisma.user.create({
      data: {
        firstName: 'Ø£Ø­Ù…Ø¯',
        lastName: 'Ø§Ù„Ù…Ø¯ÙŠØ±',
        email: 'admin@test.com',
        password: hashedPassword,
        phone: '+201234567890',
        role: 'COMPANY_ADMIN',
        isActive: true,
        isEmailVerified: true,
        companyId: company.id
      }
    });

    res.json({
      success: true,
      message: 'ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠ Ø¨Ù†Ø¬Ø§Ø­',
      data: {
        email: 'admin@test.com',
        password: 'admin123',
        role: testUser.role,
        companyId: testUser.companyId
      }
    });

  } catch (error) {
    console.error('âŒ Error creating test user:', error);
    res.status(500).json({
      success: false,
      message: 'ÙØ´Ù„ ÙÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„ØªØ¬Ø±ÙŠØ¨ÙŠ',
      error: error.message
    });
  }
};


// ==================== SMART DELAY MONITORING ENDPOINTS ====================
app.use('/api/v1/smart-delay', smartDelayRoutes);
// ==================== END SMART DELAY ENDPOINTS ====================
app.use('/api/v1/products', enhancedProductRoutes);

app.use('/api/v1/orders-new', orderRoutes2);
app.use('/api/v1/orders-enhanced', enhancedOrderRoutes);

const successLearningRoutes = require('./routes/successLearning');
app.use('/api/v1/success-learning', successLearningRoutes);


const autoPatternRoutes = require('./routes/autoPatternRoutes');
app.use('/api/v1/auto-patterns', autoPatternRoutes);


const prioritySettingsRoutes = require('./routes/prioritySettingsRoutes');
app.use('/api/v1/priority-settings', prioritySettingsRoutes);

const uploadRoutes = require('./routes/uploadRoutes');
app.use('/api/v1/upload', uploadRoutes);

// Real conversations endpoint with search support - with company isolation

app.get('/api/v1/conversations', verifyToken.authenticateToken, verifyToken.requireCompanyAccess, async (req, res) => {
  try {
    // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù…ØµØ§Ø¯Ù‚Ø© ÙˆØ§Ù„Ø´Ø±ÙƒØ©
    const companyId = req.user?.companyId;
    if (!companyId) {
      return res.status(403).json({
        success: false,
        message: 'ØºÙŠØ± Ù…ØµØ±Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ - Ù…Ø¹Ø±Ù Ø§Ù„Ø´Ø±ÙƒØ© Ù…Ø·Ù„ÙˆØ¨'
      });
    }

    const { search } = req.query;
    console.log('ğŸ“ Fetching real conversations from database for company:', companyId);

    if (search) {
      console.log(`ğŸ” Ø§Ù„Ø¨Ø­Ø« Ø¹Ù†: "${search}"`);
    }

    // Build search conditions with company filter
    let whereCondition = {
      companyId // Ø¥Ø¶Ø§ÙØ© ÙÙ„ØªØ±Ø© Ø§Ù„Ø´Ø±ÙƒØ©
    };

    if (search && search.trim()) {
      const searchTerm = search.trim();
      whereCondition = {
        AND: [
          { companyId }, // ØªØ£ÙƒØ¯ Ù…Ù† ÙÙ„ØªØ±Ø© Ø§Ù„Ø´Ø±ÙƒØ©
          {
            OR: [
              // Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø§Ø³Ù… Ø§Ù„Ø¹Ù…ÙŠÙ„
              {
                customer: {
                  OR: [
                    { firstName: { contains: searchTerm } },
                    { lastName: { contains: searchTerm } },
                    { facebookId: { contains: searchTerm } },
                    { email: { contains: searchTerm } },
                    { phone: { contains: searchTerm } }
                  ]
                }
              },
              // Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ù…Ø­ØªÙˆÙ‰ Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
              {
                messages: {
                  some: {
                    content: { contains: searchTerm }
                  }
                }
              },
              // Ø§Ù„Ø¨Ø­Ø« ÙÙŠ Ø¢Ø®Ø± Ø±Ø³Ø§Ù„Ø©
              {
                lastMessage: { contains: searchTerm }
              }
            ]
          }
        ]
      };
    }

    // Use safe database operation with fallback
    const conversations = await safeDb.execute(async (prisma) => {
      return await prisma.conversation.findMany({
        where: whereCondition,
        select: {
          id: true,
          customerId: true,
          channel: true,
          status: true,
          lastMessageAt: true,
          lastMessagePreview: true,
          metadata: true,
          createdAt: true,
          customer: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
              email: true,
              phone: true,
              facebookId: true,
            }
          },
          assignedUser: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
            }
          },
          _count: {
            select: {
              messages: {
                where: {
                  isRead: false,
                  isFromCustomer: true,
                }
              }
            }
          }
        },
        orderBy: {
          lastMessageAt: 'desc'
        },
        take: 100 // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø¹Ø¯Ø¯ Ù„Ø¶Ù…Ø§Ù† Ø¸Ù‡ÙˆØ± Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø§Øª Ø§Ù„Ø­Ø¯ÙŠØ«Ø©
      });
    }, { 
      fallback: [], // Return empty array if database is unavailable
      maxRetries: 2 // Fewer retries for this endpoint
    });

    // Transform data to match frontend format
    const transformedConversations = conversations.map(conv => {
      // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ø­Ø§Ù„Ø© AI Ù…Ù† metadata
      let aiEnabled = true; // Ø§ÙØªØ±Ø§Ø¶ÙŠ
      if (conv.metadata) {
        try {
          const metadata = JSON.parse(conv.metadata);
          aiEnabled = metadata.aiEnabled !== false;
          console.log(`ğŸ” [AI-DEBUG] Conversation ${conv.id}: metadata=${conv.metadata}, aiEnabled=${aiEnabled}`);
        } catch (error) {
          console.warn('âš ï¸ Could not parse conversation metadata:', error);
        }
      } else {
        console.log(`ğŸ” [AI-DEBUG] Conversation ${conv.id}: no metadata, using default aiEnabled=${aiEnabled}`);
      }

      return {
        id: conv.id,
        customerId: conv.customerId,
        customerName: `${conv.customer.firstName || ''} ${conv.customer.lastName || ''}`.trim() || 'Ø¹Ù…ÙŠÙ„',
        customerAvatar: null,
        customerEmail: conv.customer.email,
        customerPhone: conv.customer.phone,
        lastMessage: conv.lastMessagePreview || 'Ù„Ø§ ØªÙˆØ¬Ø¯ Ø±Ø³Ø§Ø¦Ù„',
        lastMessageTime: conv.lastMessageAt || conv.createdAt,
        timestamp: conv.lastMessageAt || conv.createdAt,
        unreadCount: conv._count.messages,
        isOnline: false, // ÙŠÙ…ÙƒÙ† ØªØ­Ø¯ÙŠØ«Ù‡ Ù„Ø§Ø­Ù‚Ø§Ù‹
        platform: conv.channel?.toLowerCase() || 'facebook',
        status: conv.status?.toLowerCase() || 'active',
        messages: [],
        customerOrders: [],
        lastRepliedBy: conv.assignedUser ? `${conv.assignedUser.firstName} ${conv.assignedUser.lastName}` : null,
        aiEnabled: aiEnabled
      };
    });

    console.log(`âœ… Found ${transformedConversations.length} real conversations${search ? ` matching "${search}"` : ''}`);

    // Ø¥Ø±Ø¬Ø§Ø¹ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø¹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¨Ø­Ø«
    res.json({
      success: true,
      data: transformedConversations,
      total: transformedConversations.length,
      search: search || null,
      message: search ? `ØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ ${transformedConversations.length} Ù…Ø­Ø§Ø¯Ø«Ø© Ù…Ø·Ø§Ø¨Ù‚Ø© Ù„Ù„Ø¨Ø­Ø«` : `ØªÙ… ØªØ­Ù…ÙŠÙ„ ${transformedConversations.length} Ù…Ø­Ø§Ø¯Ø«Ø©`
    });
  } catch (error) {
    console.error('âŒ Error fetching real conversations:', error);
    
    // Handle connection limit errors gracefully
    if (error.message.includes('max_connections_per_hour')) {
      return res.status(503).json({ 
        success: false,
        error: 'CONNECTION_LIMIT_EXCEEDED',
        message: 'Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± Ù…ØªØ§Ø­Ø© Ù…Ø¤Ù‚ØªØ§Ù‹ Ø¨Ø³Ø¨Ø¨ ØªØ¬Ø§ÙˆØ² Ø­Ø¯ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª',
        data: [],
        total: 0,
        retryAfter: 3600
      });
    }
    
    res.status(500).json({ 
      success: false,
      error: 'Internal server error',
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…'
    });
  }
});

// Real messages endpoint
app.get('/api/v1/conversations/:id/messages', async (req, res) => {
  try {
    const { id } = req.params;
    console.log(`ğŸ“¨ Fetching real messages for conversation ${id}...`);

    // Use safe database operation with fallback
    const messages = await safeDb.execute(async (prisma) => {
      return await prisma.message.findMany({
        where: {
          conversationId: id
        },
        include: {
          sender: {
            select: {
              id: true,
              firstName: true,
              lastName: true,
            }
          }
        },
        orderBy: {
          createdAt: 'asc'
        }
      });
    }, { 
      fallback: [], // Return empty array if database is unavailable
      maxRetries: 2 // Fewer retries for this endpoint
    });

    // Transform messages to match frontend format
    const transformedMessages = messages.map(msg => {
      try {
      // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„ØµÙ†Ø§Ø¹ÙŠ Ù…Ù† metadata
      let isAiGenerated = false;
      if (msg.metadata) {
        try {
          // ØªÙ†Ø¸ÙŠÙ metadata Ù‚Ø¨Ù„ parsing
          let cleanMetadata = msg.metadata;
          if (typeof cleanMetadata === 'string') {
            cleanMetadata = cleanMetadata.trim();

            // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© JSON
            if (cleanMetadata.startsWith('{') && cleanMetadata.endsWith('}')) {
              const metadata = JSON.parse(cleanMetadata);
              isAiGenerated = metadata.isAIGenerated || metadata.isAutoGenerated || false;
            } else {
              // Ø¥Ø°Ø§ Ù„Ù… ÙŠÙƒÙ† JSON ØµØ­ÙŠØ­ØŒ ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±
              isAiGenerated = cleanMetadata.includes('"isAIGenerated":true') ||
                             cleanMetadata.includes('"isAutoGenerated":true');
            }
          }
        } catch (e) {
          console.warn(`âš ï¸ Failed to parse metadata for message ${msg.id}:`, e.message);
          // Ø¥Ø°Ø§ ÙØ´Ù„ parsingØŒ ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ù†Øµ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±
          isAiGenerated = msg.metadata.includes('"isAIGenerated":true') ||
                         msg.metadata.includes('"isAutoGenerated":true');
        }
      }

      // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„ØµÙˆØ± ÙˆØ§Ù„Ù…Ø±ÙÙ‚Ø§Øª - Ù…Ø­Ø³Ù†
      let fileUrl = null;
      let fileName = null;
      let fileSize = null;

      // Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ù„Ù Ù…Ù† attachments Ø£Ùˆ metadata
      if (msg.type === 'IMAGE' || msg.type === 'FILE') {
        // Ø£ÙˆÙ„Ø§Ù‹: Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ù† attachments
        if (msg.attachments) {
          try {
            const attachments = JSON.parse(msg.attachments);
            if (attachments && attachments.length > 0) {
              const attachment = attachments[0];
              fileUrl = attachment.url || attachment.fileUrl;
              fileName = attachment.name || attachment.fileName;
              fileSize = attachment.size || attachment.fileSize;
            }
          } catch (e) {
            console.warn(`âš ï¸ Failed to parse attachments for message ${msg.id}`);
          }
        }

        // Ø«Ø§Ù†ÙŠØ§Ù‹: Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ø³ØªØ®Ø±Ø§Ø¬ Ù…Ù† metadata
        if (!fileUrl && msg.metadata) {
          try {
            const metadata = JSON.parse(msg.metadata);
            fileUrl = metadata.fileUrl;
            fileName = metadata.fileName;
            fileSize = metadata.fileSize;
          } catch (e) {
            console.warn(`âš ï¸ Failed to parse metadata for message ${msg.id}`);
          }
        }

        // Ø«Ø§Ù„Ø«Ø§Ù‹: Ù„Ù„ØµÙˆØ± Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø©ØŒ Ø§Ø³ØªØ®Ø¯Ù… content ÙƒÙ€ URL
        if (!fileUrl && msg.type === 'IMAGE' && msg.content) {
          if (msg.content.startsWith('http') || msg.content.startsWith('/uploads')) {
            fileUrl = msg.content;
            fileName = 'ØµÙˆØ±Ø©';
          }
        }

        // Ø±Ø§Ø¨Ø¹Ø§Ù‹: Ù„Ù„Ù…Ù„ÙØ§ØªØŒ Ø§Ø³ØªØ®Ø¯Ù… content ÙƒØ§Ø³Ù… Ø§Ù„Ù…Ù„Ù
        if (!fileName && msg.type === 'FILE') {
          fileName = msg.content;
        }
      }

      return {
        id: msg.id,
        content: msg.type === 'IMAGE' ? (fileName || 'ØµÙˆØ±Ø©') :
                msg.type === 'FILE' ? (fileName || msg.content) : msg.content,
        timestamp: msg.createdAt,
        isFromCustomer: msg.isFromCustomer,
        sender: msg.sender ? {
          id: msg.sender.id,
          name: `${msg.sender.firstName} ${msg.sender.lastName}`,
        } : null,
        type: msg.type?.toLowerCase() || 'text',
        attachments: (() => {
          try {
            if (!msg.attachments) return [];

            // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ù‚Ø¨Ù„ parsing
            let cleanAttachments = msg.attachments;
            if (typeof cleanAttachments === 'string') {
              // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø£Ø­Ø±Ù ØºÙŠØ± Ø§Ù„Ù…Ø±ØºÙˆØ¨ ÙÙŠÙ‡Ø§
              cleanAttachments = cleanAttachments.trim();

              // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© JSON
              if (cleanAttachments.startsWith('[') && cleanAttachments.endsWith(']')) {
                return JSON.parse(cleanAttachments);
              } else if (cleanAttachments.startsWith('{') && cleanAttachments.endsWith('}')) {
                return [JSON.parse(cleanAttachments)];
              } else {
                console.warn(`âš ï¸ Invalid JSON format for attachments in message ${msg.id}`);
                return [];
              }
            }

            return Array.isArray(cleanAttachments) ? cleanAttachments : [];
          } catch (error) {
            console.error(`âŒ Failed to parse attachments for message ${msg.id}:`, error.message);
            console.error(`âŒ Raw attachments data: "${msg.attachments?.substring(0, 200)}..."`);
            // Ø¥Ø±Ø¬Ø§Ø¹ Ù…ØµÙÙˆÙØ© ÙØ§Ø±ØºØ© ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£
            return [];
          }
        })(),
        fileUrl: fileUrl, // Ø¥Ø¶Ø§ÙØ© Ø±Ø§Ø¨Ø· Ø§Ù„Ù…Ù„Ù Ù„Ù„ØµÙˆØ±
        fileName: fileName, // Ø¥Ø¶Ø§ÙØ© Ø§Ø³Ù… Ø§Ù„Ù…Ù„Ù
        fileSize: fileSize, // Ø¥Ø¶Ø§ÙØ© Ø­Ø¬Ù… Ø§Ù„Ù…Ù„Ù
        isAiGenerated: isAiGenerated, // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ù„ÙˆÙ…Ø© Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„ØµÙ†Ø§Ø¹ÙŠ
        metadata: msg.metadata // Ø¥Ø¶Ø§ÙØ© metadata Ù„Ù„ØªØ´Ø®ÙŠØµ
      };
      } catch (messageError) {
        console.error(`âŒ Error processing message ${msg.id}:`, messageError.message);
        console.error(`âŒ Message data:`, {
          id: msg.id,
          type: msg.type,
          content: msg.content?.substring(0, 100),
          attachments: msg.attachments?.substring(0, 100),
          metadata: msg.metadata?.substring(0, 100)
        });

        // Ø¥Ø±Ø¬Ø§Ø¹ Ø±Ø³Ø§Ù„Ø© Ø¨Ø³ÙŠØ·Ø© ÙÙŠ Ø­Ø§Ù„Ø© Ø§Ù„Ø®Ø·Ø£
        return {
          id: msg.id,
          content: msg.content || '[Ø±Ø³Ø§Ù„Ø© Ù…Ø¹Ø·ÙˆØ¨Ø©]',
          type: msg.type || 'TEXT',
          timestamp: msg.createdAt,
          isFromCustomer: msg.isFromCustomer,
          attachments: [],
          isAiGenerated: false,
          metadata: null
        };
      }
    }).filter(Boolean); // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø±Ø³Ø§Ø¦Ù„ null

    // Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø±Ø³Ø§Ø¦Ù„
    const aiMessages = transformedMessages.filter(m => m.isAiGenerated).length;
    const manualMessages = transformedMessages.filter(m => !m.isFromCustomer && !m.isAiGenerated).length;
    const customerMessages = transformedMessages.filter(m => m.isFromCustomer).length;

    console.log(`âœ… Found ${transformedMessages.length} real messages:`);
    console.log(`   ğŸ‘¤ ${customerMessages} Ù…Ù† Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡`);
    console.log(`   ğŸ¤– ${aiMessages} Ù…Ù† Ø§Ù„Ø°ÙƒØ§Ø¡ Ø§Ù„ØµÙ†Ø§Ø¹ÙŠ`);
    console.log(`   ğŸ‘¨â€ğŸ’¼ ${manualMessages} ÙŠØ¯ÙˆÙŠØ©`);

    res.json(transformedMessages);
  } catch (error) {
    console.error('âŒ Error fetching real messages:', error);
    
    // Handle connection limit errors gracefully
    if (error.message.includes('max_connections_per_hour')) {
      return res.status(503).json({ 
        success: false,
        error: 'CONNECTION_LIMIT_EXCEEDED',
        message: 'Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± Ù…ØªØ§Ø­Ø© Ù…Ø¤Ù‚ØªØ§Ù‹ Ø¨Ø³Ø¨Ø¨ ØªØ¬Ø§ÙˆØ² Ø­Ø¯ Ø§Ù„Ø§ØªØµØ§Ù„Ø§Øª',
        data: [],
        retryAfter: 3600
      });
    }
    
    res.status(500).json({ 
      success: false,
      error: 'Internal server error',
      message: 'Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø®Ø§Ø¯Ù…'
    });
  }
});

// Real customer profile endpoint
app.get('/api/v1/customers/:id', async (req, res) => {
  try {
    const { id } = req.params;
    console.log(`ğŸ‘¤ Fetching real customer profile for ${id}...`);

    const customer = await prisma.customer.findUnique({
      where: { id },
      include: {
        orders: {
          orderBy: { createdAt: 'desc' },
          take: 10
        }
      }
    });

    if (!customer) {
      return res.status(404).json({ error: 'Customer not found' });
    }

    // Transform customer data
    const transformedCustomer = {
      id: customer.id,
      name: `${customer.firstName || ''} ${customer.lastName || ''}`.trim() || 'Ø¹Ù…ÙŠÙ„',
      email: customer.email,
      phone: customer.phone,
      avatar: customer.avatar,
      orders: customer.orders.map(order => ({
        id: order.id,
        total: order.total,
        status: order.status,
        date: order.createdAt
      })),
      totalSpent: customer.orders.reduce((sum, order) => sum + (order.total || 0), 0),
      joinDate: customer.createdAt,
      lastActivity: customer.updatedAt,
      preferences: {
        language: 'ar',
        notifications: true
      }
    };

    console.log(`âœ… Found real customer: ${transformedCustomer.name}`);
    res.json(transformedCustomer);
  } catch (error) {
    console.error('âŒ Error fetching real customer:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Real saved replies endpoint
app.get('/api/v1/saved-replies', async (req, res) => {
  try {
    console.log('ğŸ’¬ Fetching real saved replies from database...');

    // ÙŠÙ…ÙƒÙ† Ø¥Ø¶Ø§ÙØ© Ø¬Ø¯ÙˆÙ„ saved_replies Ù„Ø§Ø­Ù‚Ø§Ù‹ØŒ Ø§Ù„Ø¢Ù† Ù†Ø³ØªØ®Ø¯Ù… Ø±Ø¯ÙˆØ¯ Ø§ÙØªØ±Ø§Ø¶ÙŠØ©
    const savedReplies = [
      {
        id: '1',
        title: 'ØªØ±Ø­ÙŠØ¨',
        content: 'Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ! ÙƒÙŠÙ ÙŠÙ…ÙƒÙ†Ù†ÙŠ Ù…Ø³Ø§Ø¹Ø¯ØªÙƒ Ø§Ù„ÙŠÙˆÙ…ØŸ',
        category: 'welcome',
        createdAt: new Date()
      },
      {
        id: '2',
        title: 'Ø´ÙƒØ±',
        content: 'Ø´ÙƒØ±Ø§Ù‹ Ù„ØªÙˆØ§ØµÙ„Ùƒ Ù…Ø¹Ù†Ø§. Ù†Ù‚Ø¯Ø± Ø«Ù‚ØªÙƒ Ø¨Ù†Ø§.',
        category: 'thanks',
        createdAt: new Date()
      },
      {
        id: '3',
        title: 'Ø§Ø¹ØªØ°Ø§Ø±',
        content: 'Ù†Ø¹ØªØ°Ø± Ø¹Ù† Ø£ÙŠ Ø¥Ø²Ø¹Ø§Ø¬. Ø³Ù†Ø¹Ù…Ù„ Ø¹Ù„Ù‰ Ø­Ù„ Ø§Ù„Ù…Ø´ÙƒÙ„Ø© ÙÙˆØ±Ø§Ù‹.',
        category: 'apology',
        createdAt: new Date()
      },
      {
        id: '4',
        title: 'Ù…ØªØ§Ø¨Ø¹Ø©',
        content: 'Ù‡Ù„ ØªØ­ØªØ§Ø¬ Ø¥Ù„Ù‰ Ø£ÙŠ Ù…Ø³Ø§Ø¹Ø¯Ø© Ø¥Ø¶Ø§ÙÙŠØ©ØŸ',
        category: 'followup',
        createdAt: new Date()
      },
      {
        id: '5',
        title: 'Ø¥ØºÙ„Ø§Ù‚',
        content: 'Ø´ÙƒØ±Ø§Ù‹ Ù„Ùƒ. Ù†ØªÙ…Ù†Ù‰ Ù„Ùƒ ÙŠÙˆÙ…Ø§Ù‹ Ø³Ø¹ÙŠØ¯Ø§Ù‹!',
        category: 'closing',
        createdAt: new Date()
      }
    ];

    console.log(`âœ… Returning ${savedReplies.length} saved replies`);
    res.json(savedReplies);
  } catch (error) {
    console.error('âŒ Error fetching saved replies:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});



// Get Facebook user info (Ø§Ù„Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© - ØªØ¹Ù…Ù„ ÙÙ‚Ø· Ù…Ø¹ Ø§Ù„Ù…Ø·ÙˆØ±ÙŠÙ† ÙˆØ§Ù„Ø¥Ø¯Ø§Ø±ÙŠÙŠÙ†)
async function getFacebookUserInfo(userId, pageAccessToken) {
  try {
    console.log(`ğŸ” Fetching Facebook user info for: ${userId}`);
    const response = await axios.get(`https://graph.facebook.com/v18.0/${userId}`, {
      params: {
        access_token: pageAccessToken,
        fields: 'first_name,last_name,profile_pic',
      },
      timeout: 5000
    });

    console.log(`âœ… Facebook user info retrieved:`, {
      id: userId,
      name: `${response.data.first_name} ${response.data.last_name}`,
      first_name: response.data.first_name,
      last_name: response.data.last_name,
      profile_pic: response.data.profile_pic ? 'Available' : 'Not available'
    });

    return response.data;
  } catch (error) {
    console.error('âŒ Error getting Facebook user info:', error.message);
    if (error.response) {
      console.error('âŒ Facebook API Response:', {
        status: error.response.status,
        statusText: error.response.statusText,
        data: error.response.data
      });
    }
    console.error('âŒ Request details:', {
      userId: userId,
      url: `https://graph.facebook.com/v18.0/${userId}`,
      hasToken: !!pageAccessToken,
      tokenLength: pageAccessToken ? pageAccessToken.length : 0
    });
    // ÙÙŠ Ø­Ø§Ù„Ø© ÙØ´Ù„ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØŒ Ù†Ø¹ÙŠØ¯ null Ù„Ø¹Ø¯Ù… Ø§Ù„ØªØ­Ø¯ÙŠØ«
    console.log('âš ï¸ Could not get real name from Facebook, keeping existing name');
    return null;

    // Ø§Ø®ØªÙŠØ§Ø± Ø§Ø³Ù… Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ User ID
    const nameIndex = parseInt(userId.slice(-1)) % fallbackNames.length;
    return fallbackNames[nameIndex];
  }
}
// Update existing Facebook customers with real names
app.post('/api/v1/customers/update-facebook-names', async (req, res) => {
  try {
    console.log('ğŸ”„ Starting to update Facebook customer names...');

    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ù„Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ pageAccessToken
    const defaultPage = await prisma.facebookPage.findFirst({
      where: { status: 'connected' },
      orderBy: { connectedAt: 'desc' }
    });

    if (!defaultPage || !defaultPage.pageAccessToken) {
      return res.status(400).json({
        success: false,
        error: 'No connected Facebook page found'
      });
    }

    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ø§Ù„Ø°ÙŠÙ† Ù„Ø¯ÙŠÙ‡Ù… Ø£Ø³Ù…Ø§Ø¡ Ø§ÙØªØ±Ø§Ø¶ÙŠØ© (Ø¹Ø±Ø¨ÙŠØ© Ø£Ùˆ Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ©)
    const customersToUpdate = await prisma.customer.findMany({
      where: {
        AND: [
          { facebookId: { not: null } },
          {
            OR: [
              { firstName: 'Facebook' },
              { lastName: 'User' },
              { firstName: { contains: 'Facebook' } },
              { firstName: 'Ø¹Ù…ÙŠÙ„' },
              { firstName: 'Ø²Ø§Ø¦Ø±' },
              { firstName: 'Ø²Ø¨ÙˆÙ†' },
              { lastName: 'ÙƒØ±ÙŠÙ…' },
              { lastName: 'Ù…Ù…ÙŠØ²' },
              { lastName: 'Ø¹Ø²ÙŠØ²' },
              { lastName: 'Ø¬Ø¯ÙŠØ¯' }
            ]
          }
        ]
      },
      take: 50 // ØªØ­Ø¯ÙŠØ« 50 Ø¹Ù…ÙŠÙ„ ÙÙŠ Ø§Ù„Ù…Ø±Ø© Ø§Ù„ÙˆØ§Ø­Ø¯Ø© Ù„ØªØ¬Ù†Ø¨ rate limiting
    });

    console.log(`ğŸ“Š Found ${customersToUpdate.length} customers to update`);

    let updatedCount = 0;
    let errorCount = 0;

    for (const customer of customersToUpdate) {
      try {
        // Ø¬Ù„Ø¨ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠØ© Ù…Ù† Facebook
        const userInfo = await getFacebookUserInfo(customer.facebookId, defaultPage.pageAccessToken);

        if (userInfo && userInfo.first_name && userInfo.last_name) {
          // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø£Ù† Ø§Ù„Ø§Ø³Ù… Ù„ÙŠØ³ Ø§ÙØªØ±Ø§Ø¶ÙŠØ§Ù‹
          const isDefaultName = ['Facebook', 'Ø¹Ù…ÙŠÙ„', 'Ø²Ø§Ø¦Ø±', 'Ø²Ø¨ÙˆÙ†'].includes(userInfo.first_name) ||
                               ['User', 'ÙƒØ±ÙŠÙ…', 'Ù…Ù…ÙŠØ²', 'Ø¹Ø²ÙŠØ²', 'Ø¬Ø¯ÙŠØ¯'].includes(userInfo.last_name);

          if (!isDefaultName) {
            // ØªØ­Ø¯ÙŠØ« Ø§Ø³Ù… Ø§Ù„Ø¹Ù…ÙŠÙ„ Ø¨Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø­Ù‚ÙŠÙ‚ÙŠ
            await prisma.customer.update({
              where: { id: customer.id },
              data: {
                firstName: userInfo.first_name,
                lastName: userInfo.last_name
              }
            });

            console.log(`âœ… Updated customer ${customer.id}: ${customer.firstName} ${customer.lastName} â†’ ${userInfo.first_name} ${userInfo.last_name}`);
            updatedCount++;
          } else {
            console.log(`âš ï¸ Customer ${customer.id} has default name on Facebook too: ${userInfo.first_name} ${userInfo.last_name}`);
          }
        } else {
          console.log(`âš ï¸ Could not get real name for customer ${customer.id} (${customer.facebookId})`);
        }

        // ØªØ£Ø®ÙŠØ± Ù‚ØµÙŠØ± Ù„ØªØ¬Ù†Ø¨ rate limiting
        await new Promise(resolve => setTimeout(resolve, 200));

      } catch (error) {
        console.error(`âŒ Error updating customer ${customer.id}:`, error.message);
        errorCount++;
      }
    }

    console.log(`ğŸ‰ Update completed: ${updatedCount} updated, ${errorCount} errors`);

    res.json({
      success: true,
      message: `Updated ${updatedCount} customers successfully`,
      stats: {
        total: customersToUpdate.length,
        updated: updatedCount,
        errors: errorCount
      }
    });

  } catch (error) {
    console.error('âŒ Error updating Facebook customer names:', error);
    res.status(500).json({
      success: false,
      error: 'Internal server error'
    });
  }
});

// API endpoint Ù„ØªØ­Ø¯ÙŠØ« Ø£Ø³Ù…Ø§Ø¡ Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ù„Ø¹Ø±Ø¶ Facebook User ID
app.post('/api/v1/customers/update-names-to-ids', async (req, res) => {
  try {
    console.log('ğŸ”„ Starting to update customer names to show Facebook User IDs...');

    // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¹Ù…Ù„Ø§Ø¡ Ø§Ù„Ø°ÙŠÙ† Ù„Ø¯ÙŠÙ‡Ù… Facebook IDs
    const customersToUpdate = await prisma.customer.findMany({
      where: {
        facebookId: { not: null }
      },
      take: 100 // ØªØ­Ø¯ÙŠØ« 100 Ø¹Ù…ÙŠÙ„ ÙÙŠ Ø§Ù„Ù…Ø±Ø© Ø§Ù„ÙˆØ§Ø­Ø¯Ø©
    });

    console.log(`ğŸ“Š Found ${customersToUpdate.length} customers to update`);

    let updatedCount = 0;
    let errorCount = 0;

    for (const customer of customersToUpdate) {
      try {
        // ØªØ­Ø¯ÙŠØ« Ø§Ø³Ù… Ø§Ù„Ø¹Ù…ÙŠÙ„ Ù„ÙŠØ¹Ø±Ø¶ Facebook User ID ÙƒØ§Ù…Ù„Ø§Ù‹
        await prisma.customer.update({
          where: { id: customer.id },
          data: {
            firstName: customer.facebookId,
            lastName: ""
          }
        });

        console.log(`âœ… Updated customer ${customer.id}: ${customer.firstName} ${customer.lastName} â†’ Ø¹Ù…ÙŠÙ„ #${shortId}`);
        updatedCount++;

        // ØªØ£Ø®ÙŠØ± Ù‚ØµÙŠØ±
        await new Promise(resolve => setTimeout(resolve, 50));

      } catch (error) {
        console.error(`âŒ Error updating customer ${customer.id}:`, error.message);
        errorCount++;
      }
    }

    console.log(`ğŸ‰ Update completed: ${updatedCount} updated, ${errorCount} errors`);

    res.json({
      success: true,
      message: `Updated ${updatedCount} customers to show Facebook User IDs successfully`,
      stats: {
        total: customersToUpdate.length,
        updated: updatedCount,
        errors: errorCount
      }
    });

  } catch (error) {
    console.error('âŒ Error updating customer names to IDs:', error);
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Test Facebook API connection
app.get('/api/v1/facebook/test-token/:pageId', async (req, res) => {
  try {
    const { pageId } = req.params;

    const page = await prisma.facebookPage.findFirst({
      where: { pageId: pageId }
    });

    if (!page) {
      return res.status(404).json({ error: 'Page not found' });
    }

    // Test the token by getting page info
    const response = await axios.get(`https://graph.facebook.com/v18.0/${pageId}`, {
      params: {
        access_token: page.pageAccessToken,
        fields: 'name,id'
      },
      timeout: 5000
    });

    res.json({
      success: true,
      pageInfo: response.data,
      tokenValid: true
    });

  } catch (error) {
    console.error('âŒ Token test failed:', error.message);
    res.status(400).json({
      success: false,
      error: error.message,
      tokenValid: false,
      details: error.response?.data
    });
  }
});

// Update Page Access Token
app.post('/api/v1/facebook/update-token/:pageId', async (req, res) => {
  try {
    const { pageId } = req.params;
    const { pageAccessToken } = req.body;

    if (!pageAccessToken) {
      return res.status(400).json({ error: 'Page access token is required' });
    }

    // Test the new token first
    const testResponse = await axios.get(`https://graph.facebook.com/v18.0/${pageId}`, {
      params: {
        access_token: pageAccessToken,
        fields: 'name,id'
      },
      timeout: 5000
    });

    // Update the token in database
    const updatedPage = await prisma.facebookPage.update({
      where: { pageId: pageId },
      data: {
        pageAccessToken: pageAccessToken,
        status: 'connected',
        connectedAt: new Date()
      }
    });

    res.json({
      success: true,
      message: 'Token updated successfully',
      pageInfo: testResponse.data,
      updatedPage: {
        id: updatedPage.id,
        pageId: updatedPage.pageId,
        pageName: updatedPage.pageName,
        status: updatedPage.status
      }
    });

  } catch (error) {
    console.error('âŒ Token update failed:', error.message);
    res.status(400).json({
      success: false,
      error: error.message,
      details: error.response?.data
    });
  }
};





// ==================== GRACEFUL SHUTDOWN ====================

// Ù…Ø¹Ø§Ù„Ø¬Ø© Ø¥ØºÙ„Ø§Ù‚ Ø¢Ù…Ù† Ù„Ù„Ø®Ø¯Ù…Ø§Øª
process.on('SIGINT', async () => {
  console.log('\nğŸ›‘ Received SIGINT, shutting down gracefully...');

  try {
    // Ø¥ÙŠÙ‚Ø§Ù Ø®Ø¯Ù…Ø© Ø§Ù„Ø§ÙƒØªØ´Ø§Ù Ø§Ù„ØªÙ„Ù‚Ø§Ø¦ÙŠ
    console.log('ğŸ” Stopping Auto Pattern Detection Service...');
    autoPatternService.stop();

    // Ø¥ØºÙ„Ø§Ù‚ Ø§ØªØµØ§Ù„ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª
    console.log('ğŸ”Œ Closing database connection...');
    await prisma.$disconnect();

    console.log('âœ… Graceful shutdown completed');
    process.exit(0);
  } catch (error) {
    console.error('âŒ Error during graceful shutdown:', error);
    process.exit(1);
  }
});

process.on('SIGTERM', async () => {
  console.log('\nğŸ›‘ Received SIGTERM, shutting down gracefully...');

  try {
    autoPatternService.stop();
    await prisma.$disconnect();
    console.log('âœ… Graceful shutdown completed');
    process.exit(0);
  } catch (error) {
    console.error('âŒ Error during graceful shutdown:', error);
    process.exit(1);
  }
});

// Test route to convert conversation to Facebook for testing (public for testing)
app.post('/api/test/convert-to-facebook/:conversationId', (req, res, next) => {
  // Skip auth for this test route
  next();
}, async (req, res) => {
  try {
    const { conversationId } = req.params;

    console.log(`ğŸ”§ [TEST] Converting conversation ${conversationId} to Facebook...`);

    // Get conversation
    const conversation = await prisma.conversation.findUnique({
      where: { id: conversationId },
      include: { customer: true }
    });

    if (!conversation) {
      return res.status(404).json({ success: false, error: 'Conversation not found' });
    }

    // Update customer to have Facebook ID
    const testFacebookUserId = '2902798053097917'; // Test Facebook User ID
    await prisma.customer.update({
      where: { id: conversation.customerId },
      data: {
        facebookId: testFacebookUserId,
        firstName: 'Test Facebook',
        lastName: 'User'
      }
    });

    // Update conversation metadata
    const currentMetadata = conversation.metadata ? JSON.parse(conversation.metadata) : {};
    const updatedMetadata = {
      ...currentMetadata,
      pageId: '208485636722490',
      aiEnabled: true,
      platform: 'FACEBOOK'
    };

    await prisma.conversation.update({
      where: { id: conversationId },
      data: {
        metadata: JSON.stringify(updatedMetadata),
        channel: 'FACEBOOK'
      }
    });

    console.log(`âœ… [TEST] Conversation ${conversationId} converted to Facebook`);
    console.log(`ğŸ‘¤ [TEST] Customer now has Facebook ID: ${testFacebookUserId}`);

    res.json({
      success: true,
      message: 'Conversation converted to Facebook',
      conversationId,
      facebookUserId: testFacebookUserId,
      pageId: '208485636722490'
    });

  } catch (error) {
    console.error('âŒ [TEST] Error converting conversation:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Server is already started by startServer() function above

module.exports = app;