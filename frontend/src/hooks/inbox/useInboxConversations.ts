import { useState, useEffect, useCallback, useRef } from 'react';
import { useAuth } from '../useAuthSimple';
import { useCompany } from '../../contexts/CompanyContext';
import { apiClient } from '../../services/apiClient';
import { InboxConversation, InboxTab } from '../../types/inbox.types';

export interface Message {
    id: string;
    content: string;
    senderId: string;
    senderName: string;
    timestamp: Date;
    type: 'text' | 'image' | 'file' | 'video' | 'audio' | 'template' | 'IMAGE' | 'FILE' | 'VIDEO' | 'AUDIO' | 'TEMPLATE';
    isFromCustomer: boolean;
    status: 'sending' | 'sent' | 'delivered' | 'read' | 'error';
    conversationId: string;
    fileUrl?: string;
    fileName?: string;
    fileSize?: number;
    isAiGenerated?: boolean;
    metadata?: any;
    attachments?: any[];
}

// Helper to safely parse dates
const safeDate = (date: any): Date => {
    if (!date) return new Date();
    try {
        const parsed = new Date(date);
        if (isNaN(parsed.getTime())) {
            return new Date();
        }
        return parsed;
    } catch (e) {
        return new Date();
    }
};

// Helper to parse messages (unified logic)
const parseMessage = (msg: any): Message => {
    let isAiGenerated = false;
    let md: any = null;

    if (msg.metadata) {
        try {
            md = typeof msg.metadata === 'string' ? JSON.parse(msg.metadata) : msg.metadata;
            isAiGenerated = md.isAIGenerated || md.isAutoGenerated || md.source === 'ai_agent' || false;
        } catch (e) {
            // Failed to parse metadata, continue with default values
        }
    }

    // Determine sender name
    let senderName = 'العميل';
    if (!msg.isFromCustomer) {
        if (isAiGenerated) {
            senderName = 'الذكاء الاصطناعي';
        } else if (md?.employeeName) {
            senderName = md.employeeName;
        } else if (msg.sender?.name && msg.sender.name !== 'موظف') {
            senderName = msg.sender.name;
        } else {
            senderName = 'موظف';
        }
    }

    // Parse attachments if string
    let attachments = msg.attachments;
    if (typeof attachments === 'string') {
        try {
            attachments = JSON.parse(attachments);
        } catch (e) {
            attachments = [];
        }
    }

    const msgType = msg.type || 'text';
    const isMedia = ['image', 'file', 'video', 'audio', 'IMAGE', 'FILE', 'VIDEO', 'AUDIO'].includes(msgType);

    return {
        id: msg.id,
        content: msg.content,
        senderId: msg.sender?.id || msg.senderId || 'unknown',
        senderName,
        timestamp: safeDate(msg.timestamp || msg.createdAt),
        type: msgType,
        isFromCustomer: msg.isFromCustomer,
        status: 'delivered', // Default to delivered for history
        conversationId: msg.conversationId,
        fileUrl: msg.fileUrl || (isMedia ? msg.content : undefined),
        fileName: msg.fileName,
        fileSize: msg.fileSize,
        isAiGenerated,
        metadata: md,
        attachments: attachments
    };
};

export const useInboxConversations = () => {
    const { user } = useAuth();
    const { companyId } = useCompany();

    const [conversations, setConversations] = useState<InboxConversation[]>([]);
    const [selectedConversation, setSelectedConversation] = useState<InboxConversation | null>(null);
    const [messages, setMessages] = useState<Message[]>([]);
    const [loading, setLoading] = useState(true);
    const [loadingMessages, setLoadingMessages] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [messagesPage, setMessagesPage] = useState(1);
    const [hasMoreMessages, setHasMoreMessages] = useState(false);

    // Conversations pagination & filtering
    const [conversationsPage, setConversationsPage] = useState(1);
    const [hasMoreConversations, setHasMoreConversations] = useState(false);

    // Track current tab for pagination to work correctly
    const currentTabRef = useRef<string>('all');

    const currentConversationIdRef = useRef<string | null>(null);

    // Store counts from API
    const [apiCounts, setApiCounts] = useState<{ total: number; unreplied: number }>({ total: 0, unreplied: 0 });

    // Load conversations
    const loadConversations = useCallback(async (pageNum = 1, append = false, tab: string = 'all') => {
        if (!companyId) return;

        // #region agent log
        fetch('http://127.0.0.1:7242/ingest/a55d618d-6d33-466a-80f4-02d0851beecb',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'useInboxConversations.ts:125',message:'Loading conversations - start',data:{pageNum,append,tab,companyId},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
        // #endregion

        try {
            if (pageNum === 1) {
                setLoading(true);
                currentTabRef.current = tab; // Update current tab
            }
            setError(null);

            const response = await apiClient.get(`/conversations`, {
                params: {
                    companyId,
                    limit: 50, // Reduced from 100 for better initial render performance
                    page: pageNum,
                    tab: tab
                }
            });

            const result = response.data || {};
            const data = result.data || result || [];
            const pagination = result.pagination || {};
            const counts = result.counts || {};

            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/a55d618d-6d33-466a-80f4-02d0851beecb',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'useInboxConversations.ts:147',message:'Conversations API response',data:{tab,count:data.length,total:counts.total,unreplied:counts.unreplied,conversationsWithUnread:data.filter((c:any)=>c.unreadCount>0).length,conversationsLastFromCustomer:data.filter((c:any)=>c.lastMessageIsFromCustomer).length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
            // #endregion

            // Update API counts
            if (counts.total !== undefined || counts.unreplied !== undefined) {
                setApiCounts(prev => ({
                    total: counts.total ?? prev.total,
                    unreplied: counts.unreplied ?? prev.unreplied
                }));
            }

            // Check for more conversations
            setHasMoreConversations(pagination.hasNextPage || pagination.hasMore || false);
            setConversationsPage(pageNum);

            const formattedConversations: InboxConversation[] = data.map((conv: any) => {
                // Determine tab logic moved to backend ideally, mapping here for safety
                // ... logic to determine tab ...
                let currentTab: InboxTab = 'all';
                const status = (conv.status || 'active').toLowerCase();

                if (status === 'resolved' || status === 'done') {
                    currentTab = 'done';
                } else if (status === 'active' || status === 'open' || status === 'pending') {
                    let metadataTab = null;
                    if (conv.metadata) {
                        try {
                            const metadata = typeof conv.metadata === 'string' ? JSON.parse(conv.metadata) : conv.metadata;
                            metadataTab = metadata.tab || metadata.inboxTab;
                        } catch (e) {
                            // ignore parse errors
                        }
                    }
                    if (metadataTab && ['main', 'general', 'requests', 'spam'].includes(metadataTab)) {
                        currentTab = metadataTab as InboxTab;
                    } else {
                        currentTab = 'main';
                    }
                }

                return {
                    id: conv.id,
                    customerId: conv.customerId,
                    customerName: conv.customer?.name || conv.customerName || 'عميل',
                    customerAvatar: conv.customer?.avatar || conv.customerAvatar,
                    lastMessage: conv.lastMessage || 'لا توجد رسائل',
                    lastMessageTime: safeDate(conv.lastMessageTime || conv.updatedAt),
                    unreadCount: conv.unreadCount || 0,
                    platform: 'facebook' as const,
                    tab: currentTab,
                    status: status === 'resolved' || status === 'done' ? 'done' : status === 'pending' ? 'pending' : 'open',
                    assignedTo: conv.assignedTo || null,
                    assignedToName: conv.assignedToName || null,
                    tags: conv.tags || [],
                    priority: conv.priority || false,
                    snoozedUntil: conv.snoozedUntil ? safeDate(conv.snoozedUntil) : null,
                    archived: conv.archived || false,
                    muted: conv.muted || false,
                    lastStatusChange: safeDate(conv.lastStatusChange || conv.updatedAt),
                    firstResponseTime: conv.firstResponseTime || null,
                    avgResponseTime: conv.avgResponseTime || null,
                    pageName: conv.pageName,
                    pageId: conv.pageId,
                    aiEnabled: (() => {
                        if (conv.hasOwnProperty('aiEnabled') && conv.aiEnabled !== undefined) return conv.aiEnabled;
                        if (conv.metadata) {
                            try {
                                const metadata = typeof conv.metadata === 'string' ? JSON.parse(conv.metadata) : conv.metadata;
                                return metadata.aiEnabled !== false;
                            } catch (e) { return true; }
                        }
                        return true;
                    })(),
                    lastMessageIsFromCustomer: conv.lastMessageIsFromCustomer,
                    hasUnreadMessages: conv.hasUnreadMessages,
                    postId: (() => {
                        if (conv.postId) return conv.postId;
                        if (conv.metadata) {
                            try {
                                const metadata = typeof conv.metadata === 'string' ? JSON.parse(conv.metadata) : conv.metadata;
                                return metadata.postId || null;
                            } catch (e) { return null; }
                        }
                        return null;
                    })(),
                    postDetails: null,
                };
            });

            // Deduplicate
            const conversationsMap = new Map<string, InboxConversation>();
            formattedConversations.forEach(conv => {
                conversationsMap.set(conv.id, conv);
            });
            const deduplicatedConversations = Array.from(conversationsMap.values());

            if (append && pageNum > 1) {
                setConversations(prev => {
                    const existingIds = new Set(prev.map(c => c.id));
                    const newConversations = deduplicatedConversations.filter(c => !existingIds.has(c.id));
                    return [...prev, ...newConversations];
                });
            } else {
                setConversations(deduplicatedConversations); // Replace entirely for new page or tab switch
            }

        } catch (err: any) {
            console.error('❌ Error loading conversations:', err);
            setError(err.message || 'فشل في تحميل المحادثات');
        } finally {
            if (pageNum === 1) {
                setLoading(false);
            }
        }
    }, [companyId]);

    // Load more conversations - now uses currentTabRef to ensure correct pagination
    const loadMoreConversations = useCallback(() => {
        if (hasMoreConversations && !loading) {
            loadConversations(conversationsPage + 1, true, currentTabRef.current);
        }
    }, [hasMoreConversations, loading, conversationsPage, loadConversations]);

    // Load messages for a conversation
    const loadMessages = useCallback(async (conversationId: string, pageNum = 1) => {
        if (!conversationId || !companyId) return;

        if (pageNum === 1) {
            currentConversationIdRef.current = conversationId;
            setMessages([]);
        } else if (currentConversationIdRef.current !== conversationId) {
            return;
        }

        try {
            setLoadingMessages(true);

            const response = await apiClient.get(`/conversations/${conversationId}/messages`, {
                params: {
                    companyId,
                    page: pageNum,
                    limit: 50
                }
            });

            if (currentConversationIdRef.current !== conversationId) return;

            const result = response.data || {};
            const data = result.data || result || [];
            const pagination = result.pagination || {};

            setHasMoreMessages(pagination.hasNextPage || pagination.hasMore || false);
            setMessagesPage(pageNum);

            const formattedMessages: Message[] = data.map(parseMessage);

            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/a55d618d-6d33-466a-80f4-02d0851beecb',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'useInboxConversations.ts:300',message:'Messages loaded from API',data:{conversationId,pageNum,rawCount:data.length,formattedCount:formattedMessages.length,firstMsgTimestamp:formattedMessages[0]?.timestamp,lastMsgTimestamp:formattedMessages[formattedMessages.length-1]?.timestamp,hasMore:pagination.hasNextPage || pagination.hasMore},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
            // #endregion

            // Deduplicate
            const messagesMap = new Map<string, Message>();
            formattedMessages.forEach(msg => messagesMap.set(msg.id, msg));
            const deduplicatedMessages = Array.from(messagesMap.values());

            // #region agent log
            fetch('http://127.0.0.1:7242/ingest/a55d618d-6d33-466a-80f4-02d0851beecb',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'useInboxConversations.ts:307',message:'Messages after deduplication',data:{beforeDedup:formattedMessages.length,afterDedup:deduplicatedMessages.length,customerMsgs:deduplicatedMessages.filter(m=>m.isFromCustomer).length,nonCustomerMsgs:deduplicatedMessages.filter(m=>!m.isFromCustomer).length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
            // #endregion

            if (pageNum === 1) {
                setMessages(deduplicatedMessages);
                // #region agent log
                fetch('http://127.0.0.1:7242/ingest/a55d618d-6d33-466a-80f4-02d0851beecb',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'useInboxConversations.ts:312',message:'Set messages (page 1)',data:{count:deduplicatedMessages.length,messageIds:deduplicatedMessages.map(m=>m.id).slice(0,5)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
                // #endregion
            } else {
                setMessages(prev => {
                    const existingIds = new Set(prev.map(m => m.id));
                    const newMessages = deduplicatedMessages.filter(m => !existingIds.has(m.id));
                    const result = [...newMessages, ...prev];
                    // #region agent log
                    fetch('http://127.0.0.1:7242/ingest/a55d618d-6d33-466a-80f4-02d0851beecb',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'useInboxConversations.ts:318',message:'Append older messages',data:{prevCount:prev.length,newCount:newMessages.length,resultCount:result.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
                    // #endregion
                    return result;
                });
            }

        } catch (err: any) {
            console.error('❌ Error loading messages:', err);
            setError(err.message || 'فشل في تحميل الرسائل');
        } finally {
            setLoadingMessages(false);
        }
    }, [companyId]);

    const loadMoreMessages = useCallback(() => {
        if (selectedConversation && hasMoreMessages && !loadingMessages) {
            loadMessages(selectedConversation.id, messagesPage + 1);
        }
    }, [selectedConversation, hasMoreMessages, loadingMessages, messagesPage, loadMessages]);

    // Select conversation
    const selectConversation = useCallback((conversation: InboxConversation | null) => {
        // #region agent log
        fetch('http://127.0.0.1:7242/ingest/a55d618d-6d33-466a-80f4-02d0851beecb',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'useInboxConversations.ts:355',message:'Selecting conversation',data:{conversationId:conversation?.id,unreadCount:conversation?.unreadCount,lastMessageIsFromCustomer:conversation?.lastMessageIsFromCustomer},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
        // #endregion
        setSelectedConversation(conversation);
        if (conversation) {
            loadMessages(conversation.id);
            // Optimistically mark as read in UI if needed, but usually handled by effect or backend
        } else {
            setMessages([]);
            currentConversationIdRef.current = null;
        }
    }, [loadMessages]);

    // Update selected conversation from list updates
    useEffect(() => {
        if (selectedConversation && conversations.length > 0) {
            const updatedConversation = conversations.find(c => c.id === selectedConversation.id);
            if (updatedConversation && (
                updatedConversation.status !== selectedConversation.status ||
                updatedConversation.assignedTo !== selectedConversation.assignedTo ||
                updatedConversation.assignedToName !== selectedConversation.assignedToName ||
                updatedConversation.priority !== selectedConversation.priority ||
                updatedConversation.postId !== selectedConversation.postId
            )) {
                const postDetails = selectedConversation.postDetails || updatedConversation.postDetails || null;
                setSelectedConversation({
                    ...updatedConversation,
                    postDetails: postDetails
                });
            }
        }
    }, [conversations, selectedConversation]);

    // Initial load - load default 'all' tab if not called externally
    // But since component calls it, we might want to skip auto-load or default to something
    useEffect(() => {
        // We let the component trigger the first load to control the tab
    }, []);

    // Selection state
    const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());

    const toggleSelection = useCallback((id: string) => {
        setSelectedIds(prev => {
            const next = new Set(prev);
            if (next.has(id)) next.delete(id);
            else next.add(id);
            return next;
        });
    }, []);

    const selectAll = useCallback((ids: string[]) => {
        setSelectedIds(new Set(ids));
    }, []);

    const clearSelection = useCallback(() => {
        setSelectedIds(new Set());
    }, []);

    const addMessage = useCallback((newMessage: any) => {
        setMessages(prev => {
            if (prev.some(m => m.id === newMessage.id)) return prev;
            const formatted = parseMessage(newMessage);
            return [...prev, formatted];
        });
    }, []);

    const updateSelectedConversation = useCallback((updates: Partial<InboxConversation>) => {
        setSelectedConversation(prev => prev ? { ...prev, ...updates } : null);
        setConversations(prev => prev.map(conv =>
            conv.id === selectedConversation?.id ? { ...conv, ...updates } : conv
        ));
    }, [selectedConversation?.id]);

    return {
        conversations,
        selectedConversation,
        messages,
        loading,
        loadingMessages,
        error,
        selectConversation,
        loadConversations,
        loadMessages,
        loadMoreMessages,
        addMessage,
        hasMore: hasMoreMessages,
        hasMoreConversations,
        loadMoreConversations,
        updateSelectedConversation,
        selectedIds,
        toggleSelection,
        selectAll,
        clearSelection,
        apiCounts
    };
};
